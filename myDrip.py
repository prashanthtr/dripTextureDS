import numpy as np
#import seaborn as sns
from scipy import signal
import math
#import sys

from synthInterface import MySoundModel

'''
1. The drip texture is generated by a continuous frequency sweep from start to end freuqency. <br>
2. The model is specified by two interface level parameters, namely center frequency, and bandwidth(Q). <br>
3. Three synthesizer specific parameters control the timbre of the drip sound: <br>
    3.1 Phase increment  (phase increment) <br>
    3.2 Frequency increment (freq_increment) <br>
    3.3 Amplitude attenuatiion (aa) <br>
4. A synthesizer loop runs through the parameter values for a specified duration to generate drip audio samples
'''

class MyDrip(MySoundModel) :

        def __init__(self, cf=440, Q=10) :
                MySoundModel.__init__(self)
                #create a dictionary of the parameters this synth will use
                self.__addParam__("cf", 220, 440, cf)
                self.__addParam__("Q", .1, 70, Q)

        '''
        Override of base model method
        Frequency sweeper for a drip sound
            A = sine wave amplitude
            sr = sample rate (Hz)
            cf = initial frequency (Hz)
            Q = sweep range (Hz)
        '''
        def generate(self, sigLenSecs):

                '''Interface level parameters'''
                # notation for this method
                cf=self.getParam("cf")
                Q =self.getParam("Q")
                output = []

                '''Synth variables'''
                numSamples = round(sigLenSecs*self.sr) # in samples
                start_Hz = cf             # starting frequency for sweep
                stop_Hz = cf + Q          # end frequency for sweep
                phase = 0;                # phase accumulator
                fcur = start_Hz           # current frequency
                phi = 0


                '''Synth level parameters'''
                aa = Q/5                                             # amplitude attenuator (based on bandwidth)
                phase_increment = 2 * math.pi * start_Hz / self.sr   # phase increment per sample
                freq_increment = (stop_Hz - start_Hz) / numSamples   # instantaneous frequency increment per sample

                output = np.zeros(numSamples)

                for index in range(numSamples):

                        A = 1-aa*index/numSamples if index<numSamples/aa else 0 # aa=5 works well for attentuation
                        val = A * math.sin(phase + phi);    # output sample value for current sample
                        phi += phase_increment;             # increment phase accumulator
                        fcur += freq_increment;             # increment instantaneous frequency
                        phase_increment = 2 * math.pi * fcur / self.sr;  # re-calculate phase increment
                        output[index] = val

                return output
