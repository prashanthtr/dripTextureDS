import numpy as np
#import seaborn as sns
from scipy import signal
import math
#import sys

from synthInterface import MySoundModel

'''
1. The drip texture is generated by a continuous frequency sweep from start frequency (cf) to a range (sweep) of frequency movement away from cf. <br>
2. The model is specified by four parameters, CF, sweep, decay, and decay variation <br>
3. CF is specified at the user level.
3. Three synthesizer specific parameters control the timbre of the drip sound: <br>
    3.1 Sweep : Range of frequencies traveresed for the frequency sweep.
    3.2 Decay : Controls the time after which the drip signal is attentuated.
    3.3 DecayVar : Variation on the center decay time <br>
4. A synthesizer loop runs through the parameter values for a specified duration to generate drip audio samples
'''

class MyDrip(MySoundModel) :

        def __init__(self, cf=440, sweep=10, decay=5, decayVar=2) :
                MySoundModel.__init__(self)
                #create a dictionary of the parameters this synth will use
                self.__addParam__("cf", 220, 440, cf)
                self.__addParam__("sweep", .1, 70, sweep)
                self.__addParam__("decay",1, 10, decay)
                self.__addParam__("decayVar",0, 5, decayVar)

        '''
        Override of base model method
        Frequency sweeper for a drip sound
            A = sine wave amplitude
            sr = sample rate (Hz)
            cf = initial frequency (Hz)
            sweep = sweep range (Hz)
            decay = Decay rate
        '''
        def generate(self, sigLenSecs):

                '''Interface level parameters'''
                # notation for this method
                cf=self.getParam("cf")
                sweep =self.getParam("sweep")
                decay = self.getParam("decay")
                decayVar = self.getParam("decayVar")
                aa = decay - decayVar + 2*np.random.random()*decayVar

                output = []

                '''Synth variables'''
                numSamples = round(sigLenSecs*self.sr) # in samples
                start_Hz = cf             # starting frequency for sweep
                stop_Hz = cf + sweep      # starting frequency + sweep range
                phase = 0;                # phase accumulator
                fcur = start_Hz           # current frequency
                phi = 0

                '''Synth level parameters'''
                # amplitude attenuator

                phase_increment = 2 * math.pi * start_Hz / self.sr   # phase increment per sample
                freq_increment = sweep / numSamples   # instantaneous frequency increment per sample

                output = np.zeros(numSamples)

                for index in range(numSamples):

                        A = 1-aa*index/numSamples if index<numSamples/aa else 0 # aa=5 works well for attentuation
                        val = A * math.sin(phase + phi);    # output sample value for current sample
                        phi += phase_increment;             # increment phase accumulator
                        fcur += freq_increment;             # increment instantaneous frequency
                        phase_increment = 2 * math.pi * fcur / self.sr;  # re-calculate phase increment
                        output[index] = val

                return output
